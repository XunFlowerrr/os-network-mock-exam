[
  {
    "question": "เลเยอร์ Data-Link มีบทบาทสำคัญในการสื่อสารข้อมูลอย่างไร?",
    "options": [
      "จัดการเส้นทางการส่งแพ็กเก็ตทั้งหมดในเครือข่าย",
      "จัดระเบียบและควบคุมการส่งข้อมูลในระดับเชื่อมต่อระหว่างโหนด (nodes)",
      "จัดการการเชื่อมต่อ TCP/UDP ในระบบเครือข่าย",
      "ตรวจสอบสถานะของทุกโหนดในเครือข่าย"
    ],
    "answer": 1,
    "explanation": "เลเยอร์ Data-Link ทำหน้าที่จัดระเบียบและควบคุมการส่งข้อมูลระหว่างโหนด (nodes) ที่อยู่ในระดับเดียวกัน รวมถึงการตรวจจับและแก้ไขข้อผิดพลาดพื้นฐาน"
  },
  {
    "question": "การเชื่อมต่อแบบ Point-to-Point หมายถึงอะไรในเลเยอร์ Data-Link?",
    "options": [
      "การเชื่อมต่อระหว่างอุปกรณ์หลายตัวในเวลาเดียวกัน",
      "การเชื่อมต่อผ่านระบบสวิตช์โดยใช้ MAC address",
      "การเชื่อมต่อระหว่างโหนดสองโหนดเท่านั้น",
      "การเชื่อมต่อที่สามารถส่งข้อมูลได้เฉพาะทิศทางเดียว"
    ],
    "answer": 2,
    "explanation": "Point-to-Point link คือการเชื่อมต่อระหว่างโหนดสองโหนดโดยตรง ไม่มีโหนดอื่นเข้ามาแชร์ช่องสัญญาณ"
  },
  {
    "question": "สาเหตุใดที่ต้องแบ่งเลเยอร์ Data-Link ออกเป็นสองซับเลเยอร์ (two sublayers)?",
    "options": [
      "เพื่อแยกการทำงานด้านควบคุมเฟรมและการทำงานด้าน Medium Access Control",
      "เพื่อใช้ในการเข้ารหัสข้อมูลและถอดรหัสข้อมูลเท่านั้น",
      "เพื่อลดการใช้พื้นที่หน่วยความจำของเครือข่าย",
      "เพื่อให้รองรับเฉพาะการเชื่อมต่อแบบไร้สาย"
    ],
    "answer": 0,
    "explanation": "สาเหตุที่แบ่ง Data-Link Layer เป็นสองซับเลเยอร์ เช่น LLC (Logical Link Control) และ MAC (Media Access Control) ก็เพื่อแยกหน้าที่ควบคุมการส่งเฟรม (Logical Link) ออกจากการจัดการเข้าถึงสื่อกลาง (Medium Access)"
  },
  {
    "question": "การ Framing ใน Data-Link Layer มีจุดประสงค์หลักอะไร?",
    "options": [
      "เพื่อบีบอัดข้อมูลให้เล็กที่สุด",
      "เพื่อระบุตำแหน่งของจุดเริ่มต้นและจุดสิ้นสุดของเฟรม",
      "เพื่อแยกข้อมูลเสียงออกจากข้อมูลวิดีโอ",
      "เพื่อควบคุมจำนวนแพ็กเก็ตที่ส่งพร้อมกัน"
    ],
    "answer": 1,
    "explanation": "Framing คือการกำหนดขอบเขตของข้อมูล ว่าเริ่มตรงไหนและสิ้นสุดตรงไหนในแต่ละเฟรม เพื่อให้ผู้รับสามารถแยกเฟรมแต่ละชุดได้ถูกต้อง"
  },
  {
    "question": "Byte-stuffing ถูกนำมาใช้เพื่อแก้ไขปัญหาใด?",
    "options": [
      "เพื่อหลีกเลี่ยงการทำให้ข้อมูลดูเหมือนกับ flag",
      "เพื่อเพิ่มความเร็วในการส่งข้อมูล",
      "เพื่อบีบอัดข้อมูลให้เล็กลง",
      "เพื่อเข้ารหัสข้อมูลที่เป็นความลับ"
    ],
    "answer": 0,
    "explanation": "Byte-stuffing จะเพิ่มไบต์พิเศษ (escape character) ลงในข้อมูล เมื่อข้อมูลบังเอิญมี pattern ที่เหมือน flag ทำให้ตัวรับไม่เข้าใจผิดว่าเป็นจุดสิ้นสุดหรือจุดเริ่มของเฟรม"
  },
  {
    "question": "Bit-Oriented Framing ส่วนใหญ่จะใช้ pattern 01111110 เพื่อทำหน้าที่ใด?",
    "options": [
      "เป็นข้อมูลสำหรับควบคุมแรงดันไฟฟ้า",
      "เป็นตัวระบุจุดเริ่มต้นและสิ้นสุดของเฟรม (flag)",
      "เป็นตัวระบุประเภทของข้อมูลที่ส่ง",
      "เป็นรหัสผ่านสำหรับตรวจสอบสิทธิ์"
    ],
    "answer": 1,
    "explanation": "ใน Bit-Oriented Framing มักจะใช้ 01111110 เป็น flag เพื่อระบุจุดเริ่มต้นและสิ้นสุดของเฟรม หากมี pattern นี้ปรากฏในข้อมูล จึงต้องใช้ bit stuffing เพื่อป้องกันความสับสน"
  },
  {
    "question": "กระบวนการ Bit Stuffing ทำงานอย่างไรในการป้องกันการเข้าใจผิดระหว่างข้อมูลกับ flag?",
    "options": [
      "เพิ่ม bit 1 ทุกครั้งก่อนส่งข้อมูล",
      "เพิ่ม bit 0 หนึ่งตัวหลังจากพบ 5 ตัว 1 ติดต่อกันที่อยู่หลัง 0",
      "เพิ่ม byte พิเศษเมื่อเจอ flag",
      "ลดจำนวน bit ลงเมื่อพบ pattern 01111110"
    ],
    "answer": 1,
    "explanation": "Bit stuffing จะเพิ่ม bit 0 หนึ่งตัวทุกครั้งที่มีการส่ง bit 1 จำนวน 5 ตัวติดกัน (โดยมี 0 นำหน้า) เพื่อไม่ให้เกิดรูปแบบ 01111110 ซึ่งเป็น flag ทำให้ผู้รับไม่เข้าใจผิดว่าเป็นจุดสิ้นสุดของเฟรม"
  },
  {
    "question": "เหตุใดใน Bit Stuffing จึงต้องเพิ่ม bit 0 หลังจาก 5 bit 1 ติดกัน?",
    "options": [
      "เพื่อเพิ่มความเร็วในการประมวลผล",
      "เพื่อหลีกเลี่ยงไม่ให้ pattern 01111110 ปรากฏในข้อมูล",
      "เพื่อช่วยในการเข้ารหัสลับข้อมูล",
      "เพื่อปรับสมดุลของการส่งสัญญาณ"
    ],
    "answer": 1,
    "explanation": "Pattern 01111110 ใช้เป็น flag หากพบ 5 bit 1 ติดกัน อาจไปสร้าง pattern คล้าย flag ได้ จึงใส่ bit 0 เพิ่มเข้ามาเพื่อเลี่ยงไม่ให้เกิด pattern นั้น"
  },
  {
    "question": "หน้าที่หลักของ Error Control ในเลเยอร์ Data-Link คืออะไร?",
    "options": [
      "ป้องกันการเข้าถึงสื่อกลางโดยไม่มีการชนกัน",
      "ตรวจจับและแก้ไขข้อผิดพลาดที่เกิดขึ้นในการส่งข้อมูล",
      "เข้ารหัสข้อมูลด้วยอัลกอริทึมเชิงซ้อน",
      "จัดลำดับการส่งข้อมูลตามความสำคัญ"
    ],
    "answer": 1,
    "explanation": "Error Control จะตรวจจับข้อผิดพลาด (Error Detection) และบางครั้งสามารถแก้ไขข้อผิดพลาด (Error Correction) เพื่อให้การส่งข้อมูลถูกต้อง"
  },
  {
    "question": "Redundancy ใน Error Detection หมายถึงอะไร?",
    "options": [
      "การลดจำนวนบิตที่ส่ง",
      "การใส่ข้อมูลซ้ำเพื่อช่วยตรวจจับข้อผิดพลาด",
      "การส่งข้อมูลในหลายเส้นทางเพื่อสำรองกัน",
      "การแบ่งข้อมูลออกเป็นหลายเฟรมพร้อมกัน"
    ],
    "answer": 1,
    "explanation": "Redundancy คือการใส่บิตหรือข้อมูลส่วนเกินที่สามารถใช้ตรวจสอบข้อผิดพลาดได้ หากข้อมูลถูกเปลี่ยนแปลงระหว่างทาง"
  },
  {
    "question": "Block Coding มีหลักการทำงานพื้นฐานอย่างไร?",
    "options": [
      "แบ่งข้อมูลออกเป็นบล็อก ๆ แล้วเข้ารหัสเพื่อเพิ่มบิตตรวจสอบ",
      "ใช้อัลกอริทึมเข้ารหัสแบบไม่สูญเสีย (lossless)",
      "ส่งเฉพาะบล็อกแรกของข้อมูลแล้วทิ้งที่เหลือ",
      "เข้ารหัสข้อมูลซ้ำเป็นจำนวนหลายรอบ"
    ],
    "answer": 0,
    "explanation": "Block Coding จะแบ่งข้อมูลออกเป็นบล็อกขนาด k บิต แล้วสร้างบิตตรวจสอบเพิ่มอีก r บิต เพื่อสร้างโค้ดเวิร์ดขนาด n บิต (n = k + r) สำหรับตรวจจับข้อผิดพลาด"
  },
  {
    "question": "เหตุใดจึงกล่าวว่า Error-Detecting Code ไม่สามารถตรวจจับข้อผิดพลาดทุกประเภทได้?",
    "options": [
      "เพราะ Error-Detecting Code ไม่เคยทำงานได้จริง",
      "เพราะการตรวจสอบบางครั้งจะหยุดทำงานตามเงื่อนไข",
      "เพราะ Error-Detecting Code ถูกออกแบบให้ตรวจจับเฉพาะรูปแบบข้อผิดพลาดบางชนิด",
      "เพราะ Error-Detecting Code ใช้ได้กับเฉพาะเครือข่ายไร้สาย"
    ],
    "answer": 2,
    "explanation": "การตรวจจับข้อผิดพลาด (Error-Detecting Code) ถูกออกแบบตามวิธีการที่กำหนด (เช่น parity, CRC) ซึ่งสามารถตรวจจับได้เฉพาะรูปแบบข้อผิดพลาดที่สอดคล้องกับหลักการนั้น บางรูปแบบอาจเล็ดลอดไปได้"
  },
  {
    "question": "Linear Block Codes คืออะไร?",
    "options": [
      "โค้ดที่มีความยาวไม่จำกัดและไม่เป็นเชิงเส้น",
      "โค้ดที่ทุกโค้ดเวิร์ดสามารถสร้างได้จากการผสมเชิงเส้นของโค้ดเวิร์ดอื่นๆ",
      "โค้ดที่ไม่ต้องมี parity check",
      "โค้ดที่ใช้เฉพาะในเครือข่ายใยแก้วนำแสง"
    ],
    "answer": 1,
    "explanation": "Linear Block Codes เป็นโค้ดที่โค้ดเวิร์ดใด ๆ สามารถได้มาจากการผสมเชิงเส้นของโค้ดเวิร์ดอื่น ๆ ในชุด สร้างความยืดหยุ่นในการตรวจจับหรือแก้ไขข้อผิดพลาด"
  },
  {
    "question": "ใน Parity-Check Code การตรวจจับข้อผิดพลาดทำได้อย่างไร?",
    "options": [
      "ตรวจจับจากจำนวน bit 1 ว่ามีจำนวนคู่หรือคี่ตามที่กำหนด",
      "ตรวจจับจากการเปลี่ยนสัญญาณไฟฟ้าในสายเคเบิล",
      "ตรวจจับจากความยาวของเฟรม",
      "ตรวจจับจากเวลาที่ใช้ส่งข้อมูล"
    ],
    "answer": 0,
    "explanation": "Parity-Check Code จะกำหนดจำนวน bit 1 ให้เป็นคู่ (even) หรือคี่ (odd) หากความจริงไม่ตรงตามกำหนด แสดงว่าข้อมูลมีข้อผิดพลาด"
  },
  {
    "question": "Cyclic Redundancy Check (CRC) มีข้อดีหลักคืออะไร?",
    "options": [
      "ใช้การเข้ารหัสข้อมูลแบบ End-to-End Encryption",
      "ตรวจจับข้อผิดพลาดได้แม่นยำและมีโอกาสพลาดน้อย",
      "สามารถลดค่าใช้จ่ายในการติดตั้งเครือข่าย",
      "สามารถส่งข้อมูลได้เร็วกว่าโค้ดแบบอื่นหลายเท่า"
    ],
    "answer": 1,
    "explanation": "CRC เป็นโค้ดที่สามารถตรวจจับข้อผิดพลาดได้หลากหลายรูปแบบ และมีโอกาสที่จะตรวจไม่พบข้อผิดพลาดต่ำมากเมื่อเทียบกับโค้ดอื่น"
  },
  {
    "question": "ในกระบวนการ CRC Encoder จะทำงานอย่างไรกับ Divisor (Generator Polynomial)?",
    "options": [
      "นำข้อมูลทั้งหมดมาคูณด้วย Divisor",
      "นำข้อมูลมาตั้งหาร (mod 2) ด้วย Divisor เพื่อหาค่า FCS",
      "ลบข้อมูลออกจาก Divisor เพื่อกำหนดความยาว",
      "เพิ่ม Divisor ลงไปในเฟรมเป็นคีย์ถอดรหัส"
    ],
    "answer": 1,
    "explanation": "กระบวนการใน CRC Encoder คือการนำข้อมูล (ที่เติมบิตศูนย์ท้าย) มาทำการหารแบบ mod 2 ด้วย Polynomial (Divisor) แล้วเอาค่าเศษมาเป็น Frame Check Sequence (FCS)"
  },
  {
    "question": "CRC สามารถตรวจจับ Single Error และ Burst Error ได้อย่างมีประสิทธิภาพเพราะเหตุใด?",
    "options": [
      "เพราะใช้การสุ่มเลขจำนวนมาก",
      "เพราะเป็นการตรวจสอบแบบกำหนดตำแหน่ง bit",
      "เพราะ Polynomial ที่เลือกจะทำให้การเปลี่ยนแปลง bit ตรวจจับได้ง่าย",
      "เพราะใช้การสำรองข้อมูลในหลายเซิร์ฟเวอร์"
    ],
    "answer": 2,
    "explanation": "Polynomial ที่ใช้ออกแบบ CRC ถูกเลือกเพื่อให้การเปลี่ยนแปลง bit เล็ก ๆ (single error) หรือแบบ burst error สามารถตรวจจับได้ในความน่าจะเป็นที่สูง"
  },
  {
    "question": "Checksum มีหน้าที่หลักในการตรวจสอบอะไร?",
    "options": [
      "จำนวนอุปกรณ์ที่เชื่อมต่อในระบบ",
      "ผลรวมของข้อมูลเพื่อให้ทราบว่าข้อมูลมีการเปลี่ยนแปลงหรือไม่",
      "สถานะการเข้ารหัสลับของข้อมูล",
      "เวลาที่ใช้ในการส่งข้อมูลต่อหนึ่งรอบ"
    ],
    "answer": 1,
    "explanation": "Checksum ใช้หลักการคำนวณผลรวมของข้อมูล ถ้าผลรวมไม่ตรงตามที่คาดไว้ แสดงว่ามีข้อผิดพลาดเกิดขึ้น"
  },
  {
    "question": "High-Level Data-Link Control (HDLC) มีรูปแบบเฟรมพื้นฐานกี่ชนิด?",
    "options": [
      "1 ชนิด",
      "2 ชนิด",
      "3 ชนิด",
      "4 ชนิด"
    ],
    "answer": 2,
    "explanation": "HDLC แบ่งรูปแบบเฟรมเป็น 3 ชนิด ได้แก่ I-frame, S-frame, และ U-frame โดยแต่ละชนิดมีหน้าที่แตกต่างกัน"
  },
  {
    "question": "Flag field ในเฟรม HDLC มีค่าเป็นไบต์ใด?",
    "options": [
      "10011001",
      "11110000",
      "01111110",
      "00000000"
    ],
    "answer": 2,
    "explanation": "เฟรม HDLC ใช้ไบต์ 01111110 เป็น Flag field เพื่อระบุจุดเริ่มต้นและสิ้นสุดของเฟรม"
  },
  {
    "question": "Address field ในเฟรม HDLC ทำหน้าที่อะไร?",
    "options": [
      "เก็บข้อมูลส่วนควบคุมการเจรจา (negotiation)",
      "เก็บค่า CRC",
      "ระบุที่อยู่ของโหนดปลายทางหรือโหนดต้นทาง",
      "ระบุความยาวของเฟรม"
    ],
    "answer": 2,
    "explanation": "Address field ในเฟรม HDLC ใช้ระบุที่อยู่ปลายทาง (กรณีส่งจาก primary) หรือที่อยู่ต้นทาง (กรณีส่งจาก secondary) สามารถมีความยาวมากกว่า 1 ไบต์ได้"
  },
  {
    "question": "Control field ในเฟรม HDLC มีขนาดเท่าใด?",
    "options": [
      "1 หรือ 2 ไบต์",
      "8 บิตคงที่",
      "ปรับตามความเร็วของสัญญาณ",
      "3 ไบต์เสมอ"
    ],
    "answer": 0,
    "explanation": "Control field ใน HDLC สามารถเป็น 1 หรือ 2 ไบต์ได้ ขึ้นอยู่กับรูปแบบและความต้องการของเครือข่าย"
  },
  {
    "question": "I-frame ใน HDLC ใช้สำหรับวัตถุประสงค์ใด?",
    "options": [
      "ส่งข้อมูลผู้ใช้พร้อมข้อมูลควบคุม (Flow และ Error Control) แบบ piggybacking",
      "ส่งข้อมูลการจัดการระบบเท่านั้น",
      "ส่งข้อมูลยืนยันการรับแพ็กเก็ตเท่านั้น",
      "ใช้เฉพาะในการสื่อสารแบบ multicast"
    ],
    "answer": 0,
    "explanation": "I-frame (Information frame) มีไว้สำหรับส่งข้อมูลผู้ใช้ และสามารถแนบข้อมูลควบคุมไปด้วย เช่น หมายเลข sequence และ acknowledgement เรียกว่า piggybacking"
  },
  {
    "question": "S-frame (Supervisory frame) ใน HDLC ถูกใช้เมื่อใด?",
    "options": [
      "เมื่อไม่สามารถใช้ piggybacking สำหรับการควบคุมได้",
      "เมื่อมีการส่งข้อมูลเสียง (voice) เท่านั้น",
      "เมื่อส่งข้อมูลผ่านเครือข่ายไร้สายเท่านั้น",
      "เมื่อระบบต้องการรีเซ็ตการเชื่อมต่อทั้งหมด"
    ],
    "answer": 0,
    "explanation": "S-frame ถูกใช้สำหรับส่งข้อมูลเกี่ยวกับการควบคุม Flow และ Error แบบไม่มีการ piggyback เช่น ส่ง ACK หรือ NAK แยกต่างหากจาก I-frame"
  },
  {
    "question": "U-frame (Unnumbered frame) ใน HDLC เหมาะสำหรับการสื่อสารแบบใด?",
    "options": [
      "ใช้สำหรับรับ-ส่งข้อมูลปกติทั้งหมด",
      "ใช้สำหรับการแลกเปลี่ยนข้อมูลควบคุมเซสชันหรือการจัดการเชื่อมต่อ",
      "ใช้เฉพาะกับการส่งข้อมูลมัลติมีเดีย",
      "ใช้สำหรับการเข้ารหัสข้อมูลเท่านั้น"
    ],
    "answer": 1,
    "explanation": "U-frame ถูกออกแบบมาให้ใช้สำหรับส่งข้อมูลควบคุมและจัดการเซสชัน (session management) โดยอาจมีการส่งข้อมูลระบบที่ไม่ใช่ข้อมูลผู้ใช้"
  },
  {
    "question": "P/F bit ใน I-frame ของ HDLC หมายถึงอะไร?",
    "options": [
      "บิตระบุรูปแบบการเข้ารหัส",
      "บิตกำหนดความยาวของเฟรม",
      "Poll/Final bit สำหรับระบุคำสั่งหรือคำตอบระหว่างสถานี",
      "Priority/Frequency bit สำหรับจัดลำดับความสำคัญ"
    ],
    "answer": 2,
    "explanation": "P/F bit มีความหมายว่า Poll (เมื่อ primary สอบถาม secondary) หรือ Final (เมื่อ secondary ตอบกลับ primary) ช่วยบริหารการควบคุม"
  },
  {
    "question": "Point-to-Point Protocol (PPP) เป็นโพรโตคอลแบบใด?",
    "options": [
      "Bit-oriented protocol",
      "Byte-oriented protocol",
      "Frame-oriented protocol",
      "Packet-oriented protocol"
    ],
    "answer": 1,
    "explanation": "PPP เป็น Byte-oriented protocol ซึ่งใช้ไบต์สัญลักษณ์พิเศษ (flag) และ escape byte"
  },
  {
    "question": "ใน PPP ตัว Escape Byte มีค่าใดตามมาตรฐาน?",
    "options": [
      "01111110",
      "01111101",
      "01010101",
      "11110000"
    ],
    "answer": 1,
    "explanation": "PPP ใช้ 01111101 เป็น escape byte เพื่อบ่งบอกว่าบайтถัดไปเป็นข้อมูลพิเศษหรือ flag ที่ถูกใส่มาในข้อมูล"
  },
  {
    "question": "PPP Frame มีช่อง (field) ใดบ้างที่คล้ายกับ HDLC?",
    "options": [
      "Flag, Address, Control, Protocol, Payload, FCS",
      "Flag, Header, Data, Footer",
      "Type, Length, Value",
      "Source, Destination, Checksum"
    ],
    "answer": 0,
    "explanation": "PPP Frame มีลักษณะคล้าย HDLC โดยประกอบด้วย Flag, Address, Control, Protocol, Payload (ข้อมูล), และ FCS"
  },
  {
    "question": "LCP (Link Control Protocol) ใน PPP ทำหน้าที่อะไร?",
    "options": [
      "ควบคุมการเจรจา (configure) และจัดการการเชื่อมต่อ PPP",
      "เข้ารหัสข้อมูลทั้งหมดในระดับเครือข่าย",
      "ส่งข้อมูลภาพและเสียงเท่านั้น",
      "ใช้แก้ไขข้อผิดพลาดระดับกายภาพ"
    ],
    "answer": 0,
    "explanation": "LCP ใช้ในการเจรจา (configure) ตั้งค่า และควบคุมการเชื่อมต่อของ PPP ก่อนเข้าสู่เฟสส่งข้อมูลจริง"
  },
  {
    "question": "Password Authentication Protocol (PAP) ใน PPP มีลักษณะอย่างไร?",
    "options": [
      "ใช้การแฮชรหัสผ่านแบบ MD5 ทุกครั้ง",
      "ใช้วิธีการส่งชื่อผู้ใช้และรหัสผ่านโดยตรงแบบสองขั้นตอน",
      "ไม่ต้องส่งรหัสผ่าน ใช้การยืนยันด้วย IP",
      "ใช้กระบวนการสามขั้นตอนที่ส่ง Challenge และ Response"
    ],
    "answer": 1,
    "explanation": "PAP จะส่งชื่อผู้ใช้และรหัสผ่านจากเครื่องผู้ใช้ไปยังระบบปลายทาง จากนั้นระบบจะตรวจสอบและอนุมัติหรือปฏิเสธตามความถูกต้อง"
  },
  {
    "question": "CHAP (Challenge Handshake Authentication Protocol) ใน PPP ให้ความปลอดภัยมากกว่า PAP ด้วยวิธีใด?",
    "options": [
      "ใช้การส่งรหัสผ่านซ้ำหลายครั้งติดกัน",
      "ไม่ต้องใช้รหัสผ่านเลย",
      "ใช้การท้าทาย (challenge) และตอบโต้ (response) ที่เข้ารหัส",
      "กำหนดให้ส่งรหัสผ่านใหม่ทุกครั้งที่เชื่อมต่อ"
    ],
    "answer": 2,
    "explanation": "CHAP ใช้สามขั้นตอน ได้แก่ Challenge จากระบบ, การ Response ที่เข้ารหัสจากผู้ใช้, และการตรวจสอบที่ระบบ วิธีนี้จึงมีความปลอดภัยสูงกว่าการส่งรหัสผ่านตรง ๆ"
  },
  {
    "question": "Network Control Protocol (NCP) ใน PPP ถูกกำหนดไว้เพื่ออะไร?",
    "options": [
      "ควบคุมการส่งข้อมูลแบบ Multicast",
      "ใช้ในการเชื่อมต่อเว็บเซิร์ฟเวอร์เท่านั้น",
      "กำหนดขั้นตอนควบคุมการเชื่อมต่อในระดับเน็ตเวิร์กโปรโตคอลต่าง ๆ",
      "ใช้ในการตรวจจับการชนกันของข้อมูล"
    ],
    "answer": 2,
    "explanation": "NCP ใน PPP ถูกกำหนดไว้เพื่อสนับสนุนการเชื่อมต่อกับโปรโตคอลเครือข่ายหลายชนิด เช่น IPCP สำหรับ IP เป็นการตั้งค่าและควบคุมในระดับ Network Layer"
  },
  {
    "question": "Random Access Protocol ในการส่งข้อมูล หมายถึงแนวคิดใดต่อไปนี้?",
    "options": [
      "แต่ละสถานีจองเวลาในการส่งข้อมูลล่วงหน้า",
      "สถานีจะใช้กำหนดการสลับกันส่งข้อมูล",
      "สถานีสามารถส่งข้อมูลได้ทันทีที่ต้องการ อาจเกิดการชนกัน (collision)",
      "สถานีจำเป็นต้องขออนุญาตจากสถานีกลางทุกครั้งก่อนส่ง"
    ],
    "answer": 2,
    "explanation": "Random Access Protocol อนุญาตให้ทุกสถานีส่งข้อมูลได้ตลอดเวลา ทำให้มีโอกาสเกิดการชนกันของข้อมูลได้ จึงต้องมีวิธีตรวจจับหรือหลีกเลี่ยง"
  },
  {
    "question": "Collision คืออะไรในบริบทของ Random Access Protocol?",
    "options": [
      "การสูญเสียข้อมูลเนื่องจากล้มเหลวของฮาร์ดแวร์",
      "การที่แพ็กเก็ตถูกบล็อกโดยไฟร์วอลล์",
      "การที่สองสถานีส่งข้อมูลพร้อมกันทำให้สัญญาณซ้อนทับกัน",
      "การเชื่อมต่อที่ผิดพลาดระหว่างเราเตอร์สองเครื่อง"
    ],
    "answer": 2,
    "explanation": "Collision เกิดขึ้นเมื่อมีการส่งข้อมูลโดยสองหรือมากกว่าสถานีพร้อมกันในช่องสัญญาณเดียวกัน ทำให้สัญญาณทับซ้อนและข้อมูลเสียหาย"
  },
  {
    "question": "Carrier Sense Multiple Access (CSMA) คืออะไร?",
    "options": [
      "โพรโตคอลที่แต่ละสถานีต้องตรวจสอบช่องสัญญาณก่อนส่ง",
      "โพรโตคอลที่ใช้ในเครือข่ายโทรศัพท์มือถือ",
      "โพรโตคอลที่รับประกันการไม่เกิด collision เลย",
      "โพรโตคอลที่ใช้ Token Ring"
    ],
    "answer": 0,
    "explanation": "CSMA บังคับให้สถานีตรวจสอบ (sense) ว่าช่องสัญญาณว่างหรือไม่ก่อนเริ่มส่งข้อมูล เพื่อช่วยลดโอกาสการชนกัน"
  },
  {
    "question": "Vulnerable time ใน CSMA คืออะไร?",
    "options": [
      "ช่วงเวลาที่ข้อมูลจะถูกเปลี่ยนแปลงโดยไม่ได้รับอนุญาต",
      "เวลาที่ใช้ยืนยันตัวตนบนเครือข่าย",
      "เวลาที่สัญญาณต้องใช้ในการแพร่กระจายจากปลายหนึ่งไปยังอีกปลายหนึ่ง",
      "เวลาที่แต่ละสถานีต้องหยุดพักก่อนส่งข้อมูลถัดไป"
    ],
    "answer": 2,
    "explanation": "Vulnerable time ใน CSMA คือค่า Tp (propagation time) ซึ่งเป็นเวลาที่สัญญาณต้องใช้เดินทางจากสถานีหนึ่งไปยังอีกสถานีหนึ่ง ช่วงนี้มีโอกาสเกิดการชนกันได้"
  },
  {
    "question": "เหตุใดจึงต้องใช้วิธีการ Persistent หลายแบบ (1-persistent, nonpersistent, p-persistent) ใน CSMA?",
    "options": [
      "เพื่อกำหนดวิธีการส่งต่อข้อมูลในสถานีหลัก",
      "เพื่อปรับเปลี่ยนวิธีรอหรือส่งใหม่เมื่อช่องสัญญาณไม่ว่าง",
      "เพื่อใช้เข้ารหัสข้อมูลระหว่างการส่ง",
      "เพื่อยืนยันตัวตนของผู้ใช้ในระบบ"
    ],
    "answer": 1,
    "explanation": "Persistent methods ต่างกันในการกำหนดวิธีที่สถานีจะรอหรือส่งข้อมูลใหม่ เมื่อพบว่าช่องสัญญาณไม่ว่าง ช่วยลดปัญหาการชนกัน"
  },
  {
    "question": "CSMA/CD (Collision Detection) ทำงานต่างจาก CSMA อย่างไร?",
    "options": [
      "CSMA/CD ไม่ต้องตรวจสอบช่องสัญญาณก่อนส่ง",
      "CSMA/CD ตรวจจับการชนกันและหยุดส่งทันทีเพื่อลดเวลาที่เสีย",
      "CSMA/CD ไม่สามารถใช้ใน Ethernet",
      "CSMA/CD รับประกันว่าไม่มีการสูญหายของข้อมูล"
    ],
    "answer": 1,
    "explanation": "CSMA/CD นอกจากจะตรวจสอบก่อนส่งแล้ว ยังตรวจจับการชนกันขณะส่ง (collision detection) หากพบว่าจะหยุดส่งและแจ้งสถานีอื่น แล้วทำการส่งซ้ำภายหลัง"
  },
  {
    "question": "ใน CSMA/CD เมื่อสถานีตรวจจับการชนกันได้ สถานีทำอย่างไร?",
    "options": [
      "ส่งข้อมูลต่อไปไม่หยุด",
      "หยุดส่งข้อมูลทันทีและส่งสัญญาณเจ๊ง (jam signal)",
      "รีเซ็ตสถานีและเชื่อมต่อใหม่",
      "ปิดการทำงานของระบบทั้งหมด"
    ],
    "answer": 1,
    "explanation": "เมื่อสถานีจับได้ว่ามีการชนกัน มันจะหยุดส่งข้อมูลแล้วส่ง jam signal เพื่อแจ้งสถานีอื่น ๆ จากนั้นจะรอช่วงเวลาหนึ่ง (backoff) ก่อนส่งซ้ำ"
  },
  {
    "question": "Reservation Protocol ใน Controlled Access หมายถึงอะไร?",
    "options": [
      "แต่ละสถานีจะจับจองช่องสัญญาณล่วงหน้าเพื่อส่งข้อมูล",
      "การหมุนเวียน token ในเครือข่าย",
      "การตั้งค่าเส้นทางในระดับเครือข่าย",
      "การแบ่งช่องสัญญาณเป็นสลอตเวลาและให้ทุกสถานีใช้งานพร้อมกัน"
    ],
    "answer": 0,
    "explanation": "ใน Reservation Protocol สถานีจะต้องจองเวลาส่งข้อมูลล่วงหน้า หากได้รับอนุมัติจึงจะส่งข้อมูลได้ ช่วยลดปัญหาการชนกัน"
  },
  {
    "question": "Polling ในโปรโตคอล Controlled Access ทำงานอย่างไร?",
    "options": [
      "สถานีทุกเครื่องจะส่งพร้อมกันและสุ่มตรวจสอบ",
      "มีสถานีหลัก (primary) สอบถามสถานีรอง (secondary) ทีละสถานีว่ามีข้อมูลหรือไม่",
      "ใช้วิธีการประมูลช่องสัญญาณสูงสุด",
      "ส่งข้อมูลแบบ broadcast ถึงทุกสถานีพร้อมกัน"
    ],
    "answer": 1,
    "explanation": "Polling มีสถานีหลัก (primary) คอยสลับถาม (poll) สถานีรอง (secondary) ว่าต้องการส่งข้อมูลไหม เพื่อจัดระเบียบการใช้สื่อกลาง"
  },
  {
    "question": "Token Passing เป็นวิธีการใดใน Controlled Access?",
    "options": [
      "การจับฉลากเพื่อเลือกสถานีที่จะส่ง",
      "การส่งโทเค็นวนไปแต่ละสถานี เมื่อได้โทเค็นจึงส่งข้อมูล",
      "การกำหนดให้มีสถานีเดียวที่ส่งได้ตลอดเวลา",
      "การสลับการส่งด้วยการใช้เวลาของแต่ละสถานี"
    ],
    "answer": 1,
    "explanation": "Token Passing คือการส่งโทเค็นวนระหว่างสถานีต่าง ๆ สถานีที่ถือโทเค็นมีสิทธิ์ส่งข้อมูล ช่วยควบคุมไม่ให้เกิดการชนกัน"
  },
  {
    "question": "Link-Layer Addressing มีกี่ประเภทหลักตามที่กล่าวถึง?",
    "options": [
      "1 ประเภท",
      "2 ประเภท",
      "3 ประเภท",
      "4 ประเภท"
    ],
    "answer": 2,
    "explanation": "Link-Layer Addressing แบ่งออกเป็น 3 ประเภทหลัก ได้แก่ Unicast, Multicast และ Broadcast"
  },
  {
    "question": "ข้อใดคือสาเหตุที่ทำให้เลเยอร์ Data-Link ต้องสนใจ Link-Layer Addressing?",
    "options": [
      "เพราะเลเยอร์ Data-Link ทำงานคนละส่วนกับ Network Layer อย่างสิ้นเชิง",
      "เพราะต้องมีการกำหนดที่อยู่สำหรับส่งข้อมูลถึงโหนดปลายทางใน LAN",
      "เพราะต้องใช้ในการเปิด-ปิดพอร์ต USB",
      "เพราะใช้สำหรับยืนยันตัวตนของผู้ใช้เท่านั้น"
    ],
    "answer": 1,
    "explanation": "Data-Link Layer ต้องสนใจที่อยู่ของโหนดในเครือข่ายเฉพาะ (LAN) เพื่อให้สามารถส่งเฟรมไปถึงจุดหมายในขอบเขตเลเยอร์ได้ถูกต้อง"
  },
  {
    "question": "ข้อใดต่อไปนี้เป็นคุณสมบัติของการส่งแบบ Broadcast Address?",
    "options": [
      "ส่งข้อมูลถึงโหนดต้นทางเท่านั้น",
      "ส่งข้อมูลถึงโหนดปลายทางเพียงโหนดเดียว",
      "ส่งข้อมูลถึงทุกโหนดในเครือข่าย",
      "ส่งข้อมูลไปยังโหนดที่มีแอดเดรสเป็นเลขคู่เท่านั้น"
    ],
    "answer": 2,
    "explanation": "Broadcast Address เป็นการส่งข้อมูลถึงทุกโหนดที่เชื่อมต่ออยู่ในเครือข่ายเดียวกัน (segment เดียวกัน) โดยไม่ระบุปลายทางเฉพาะ"
  },
  {
    "question": "ข้อดีของการใช้ Cyclic Codes เช่น CRC เมื่อเทียบกับ Parity-Check Code คืออะไร?",
    "options": [
      "ประหยัดทรัพยากรมากกว่า",
      "ตรวจจับข้อผิดพลาดได้ครอบคลุมและแม่นยำกว่า",
      "สามารถเข้ารหัสข้อมูลให้เป็นข้อความลับได้",
      "ไม่ต้องใช้อุปกรณ์ฮาร์ดแวร์พิเศษใด ๆ"
    ],
    "answer": 1,
    "explanation": "CRC สามารถตรวจจับข้อผิดพลาดได้หลากหลายรูปแบบมากกว่า Parity-Check ธรรมดา ทำให้ความแม่นยำและครอบคลุมสูงขึ้น"
  },
  {
    "question": "CHAP ใช้ขั้นตอนใดในการตรวจสอบความถูกต้องของผู้ใช้?",
    "options": [
      "ผู้ใช้ส่งชื่อและรหัสผ่านในแพ็กเก็ตเดียวกันทุกครั้ง",
      "ผู้ใช้จะได้รับ Challenge และส่ง Response ที่เข้ารหัสกลับไป",
      "ระบบจะโทรศัพท์สอบถามรหัสผ่านจากผู้ใช้",
      "ผู้ใช้จะต้องป้อน Captcha ทุกครั้งที่เชื่อมต่อ"
    ],
    "answer": 1,
    "explanation": "CHAP ใช้กระบวนการสามขั้นตอน ได้แก่ Challenge จากระบบ, การ Response ที่เข้ารหัส, และการยืนยันผล ทำให้รหัสผ่านไม่ถูกส่งออกไปตรง ๆ"
  },
  {
    "question": "ในการแบ่งกลุ่มของ Multiple Access Protocols ข้อใดอยู่ในกลุ่ม Random Access?",
    "options": [
      "Polling",
      "CSMA/CD",
      "Token Passing",
      "Reservation Protocol"
    ],
    "answer": 1,
    "explanation": "Random Access Protocols ประกอบด้วย ALOHA, CSMA, CSMA/CD, CSMA/CA ซึ่ง CSMA/CD ก็เป็นหนึ่งในกลุ่มนี้"
  },
  {
    "question": "ฟิลด์ FCS (Frame Check Sequence) ในเฟรม HDLC มักจะใช้การตรวจสอบแบบใด?",
    "options": [
      "Parity Check",
      "CRC",
      "Checksum",
      "Encryption Key"
    ],
    "answer": 1,
    "explanation": "FCS ของ HDLC มักจะเป็นฟิลด์ CRC 16 หรือ CRC 32 เพื่อใช้ตรวจสอบและตรวจจับข้อผิดพลาดที่เกิดขึ้นในการส่งข้อมูล"
  },
  {
    "question": "PPP Transition Phase คืออะไร?",
    "options": [
      "กระบวนการเปลี่ยนสัญญาณอนาล็อกเป็นดิจิทัล",
      "การเปลี่ยนสถานะของการเชื่อมต่อ PPP เช่น Establish, Authenticate, Network",
      "การเปลี่ยนความถี่ในการส่งข้อมูล",
      "การเปลี่ยนรูปแบบจาก Byte-oriented เป็น Bit-oriented"
    ],
    "answer": 1,
    "explanation": "PPP Transition Phase คือการเปลี่ยนสถานะต่าง ๆ ของ PPP เช่น เริ่มเชื่อมต่อ (Establish), ทำการยืนยันตัวตน (Authenticate), และเข้าสู่การส่งข้อมูล (Network)"
  },
  {
    "question": "Multilink PPP มีจุดประสงค์ใด?",
    "options": [
      "เพิ่มความปลอดภัยด้วยการเข้ารหัสสองชั้น",
      "เพิ่มแบนด์วิดท์ด้วยการรวมหลายลิงก์เป็นลิงก์เดียวเชิงตรรกะ",
      "ทำให้การเชื่อมต่อรองรับการใช้งาน Satellite เท่านั้น",
      "ลดเวลาหน่วงด้วยการกำหนดเส้นทางหลายเส้นทาง"
    ],
    "answer": 1,
    "explanation": "Multilink PPP ช่วยรวมหลาย Physical Link เข้าด้วยกันให้กลายเป็นลิงก์เชิงตรรกะเดียว เพิ่มแบนด์วิดท์และรองรับการกระจายภาระงาน"
  },
  {
    "question": "ในระบบ CSMA/CD ช่วงเวลา Backoff ถูกใช้เพื่ออะไร?",
    "options": [
      "กำหนดเวลาส่งการยืนยันกลับไปยังผู้ส่ง",
      "คำนวณ CRC ใหม่เพื่อตรวจสอบความถูกต้อง",
      "หน่วงเวลาก่อนส่งซ้ำหลังจากตรวจจับ Collision",
      "ป้องกันการชนกันระหว่างเฟรม Broadcast"
    ],
    "answer": 2,
    "explanation": "CSMA/CD จะให้สถานีที่พบการชนกันหยุดส่งและรอเวลาที่คำนวณแบบ Backoff เพื่อไม่ให้สถานีเหล่านั้นส่งข้อมูลพร้อมกันอีก"
  },
  {
    "question": "ข้อใดคือข้อได้เปรียบของการใช้ Token Passing ในเครือข่ายแบบ Ring?",
    "options": [
      "ลดค่าใช้จ่ายในการติดตั้งสายเคเบิล",
      "ตัดปัญหาการชนกันเพราะมีเพียงสถานีที่ถือ Token เท่านั้นที่ส่งได้",
      "ไม่ต้องใช้ Address Field ในเฟรม",
      "ปรับเปลี่ยนความเร็วได้อัตโนมัติทุกสถานี"
    ],
    "answer": 1,
    "explanation": "Token Passing ช่วยให้เกิดการส่งข้อมูลแบบเป็นระเบียบ เนื่องจากมีแค่สถานีที่ถือโทเค็นเท่านั้นที่สามารถส่ง จึงไม่มีการชนกัน"
  }
]
